# 动态分配：堆

## 堆的理解

堆（heap）是为动态分配预留的内存空间。和栈不一样，从堆上分配和重新分配块没有固定模式；你可以在任何时候分配和释放它。这样使得跟踪哪部分堆已经被分配和被释放变的异常复杂；有许多定制的堆分配策略用来为不同的使用模式下调整堆的性能。

每一个线程都有一个栈，但是每一个应用程序通常都只有一个堆（尽管为不同类型分配内存使用多个堆的情况也是有的）。 直接回答你的问题：

- 当线程创建的时候，操作系统（OS）为每一个系统级（system-level）的线程分配栈。通常情况下，操作系统通过调用语言的运行时（runtime）去为应用程序分配堆。
- 栈附属于线程，因此当线程结束时栈被回收。堆通常通过运行时在应用程序启动时被分配，当应用程序（进程）退出时被回收。
- 当线程被创建的时候，设置栈的大小。在应用程序启动的时候，设置堆的大小，但是可以在需要的时候扩展（分配器向操作系统申请更多的内存）。
- 栈比堆要快，因为它存取模式使它可以轻松的分配和重新分配内存（指针/整型只是进行简单的递增或者递减运算），然而堆在分配和释放的时候有更多的复杂的 bookkeeping 参与。另外，在栈上的每个字节频繁的被复用也就意味着它可能映射到处理器缓存中，所以很快（译者注：局部性原理）。

## Java 中的 GC 堆

![java GC heap](https://img2020.cnblogs.com/blog/1320926/202003/1320926-20200309200733774-425387437.png)

**新生代**：新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例。

**旧生代**：用于存放新生代中经过多次垃圾回收仍然存活的对象。

Java中的堆也是GC收集垃圾的主要区域。GC分为两种：**Minor GC、FullGC**(或称为Major GC)。
Minor GC是发生在新生代中的垃圾收集动作，所采用的是复制算法。

新生代几乎是所有Java对象出生的地方，即Java对象申请的内存以及存放都是在这个地方。Java中的大部分对象通常不需长久存活，具有朝生夕灭的性质。当一个对象被判定为 "死亡" 的时候，GC就有责任来回收掉这部分对象的内存空间。新生代是GC收集垃圾的频繁区域。当对象在Eden(包括一个Survivor区域，这里假设是from区域)出生后，在经过一次Minor GC后，如果对象还存活，并且能够被另外一块Survivor区域所容纳(上面已经假设为from 区域，这里应为to区域，即to区域有足够的内存空间来存储Eden和from区域中存活的对象)，则使用复制算法将这些仍然还存活的对象复制到另外一块Survivor区域(即to区域)中，然后清理所使用过的Eden以及Survivor区域( 即from区域)，并且将这些对象的年龄设置为1，以后对象在Survivor区每熬过一次Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是15岁，可以通过参数 -XX:MaxTenuringThreshold来设定 )，这些对象就会成为老年代。但这也不是一定的，对于一些较大的对象(即需要分配一块较大的连续内存空间)则是直接进入到老年代。

Full GC是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。Full GC发生的次数不会有Minor GC那么频繁，并且做一次Full GC要比进行一次Minor GC的时间更长。 另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片(即不连续的内存空间)，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次GC的收集动作。

## C# 中的 GC

C#`new`一个新对象时，CLR会执行以下操作：

1. 计算类型的字段（包括从基类继承的字段）所需的字节数。
2. 加上对象开销所需的字节数。每个对象都有两个开销字段：类型对象指针和同步块索引，32位程序为8字节，64位程序为16字节。
3. CLR检查托管堆是否有足够的可用空间，如果有，则将对象放入`NextObjPtr`指向的地址，并将对象分配的字节清零。接着调用构造器，对象引用返回之前，`NextObjPtr`加上对象真正占用的字节数得到下一个对象的分配位置。

主要流程：

1.首先，CLR**暂停进程中的所有线程**。防止线程在CLR检查期间访问对象并更改其状态。

2.然后，CLR进入**GC的标记阶段**。

 a. CLR遍历堆中的对象（实际上是某些代的对象，这里可以先认为是所有对象），将同步块索引字段中的一位设为0，表示对象是`不可达`的，要被删除。

 b. CLR遍历所有`根`，将所引用对象的同步块索引位设为1，表示对象是`可达`的，要保留。

3.接着，CLR进入**GC的碎片整理阶段**。

 a. 将可达对象压缩到连续的内存空间（大对象堆的对象不会被压缩）

 b. 重新计算`根`所引用对象的地址。

4.最后，`NextObjPtr`指针指向最后一个可达对象之后的位置，恢复应用程序的所有线程。

![c sharp gc](https://img2018.cnblogs.com/blog/1010000/201907/1010000-20190716112337307-97201895.png)

CLR的GC是`基于代的垃圾回收器`，它假设：

- 对象越新，生存期越短
- 对象越老，生存期越长
- 回收堆的一部分，速度快于回收整个堆

托管堆最多支持三代对象：

- 第0代对象：新构造的**未被GC检查过**的对象
- 第1代对象：被GC**检查过1次**且保留下来的对象
- 第2代对象：被GC检查**大于等于2**次且保留下来的对象
