# 银行家算法

王道的教材一边说着“考生的应试教育准备方法总是去死背公式，不去理解背后的知识”一边把银行家算法这么简单个问题列了两页公式……

当一个进程申请使用资源的时候，银行家算法通过先**试探**分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。

## Available 向量

就是系统**当前可用的资源向量**，每个元素表示该类资源的可用数量。

## Allocation 矩阵

表示**当前已分配给各进程的资源数**，每个元素表示该进程已分配的该类资源数。也就是每个进程已经分配了多少资源。是当前进程自己持有的。这个名字更应该写成 `Allocated`。

## Max 矩阵

表示进程**总共需要的各类资源数**，每个元素表示该进程对该类资源的最大需求。是当前进程最大可能需要的，进程不会申请超过这个数的资源。

## Need 矩阵

表示进程**还需要的各类资源数**，每个元素表示该进程还需要的该类资源数。是当前进程还需要的。

显然，`目前需要的 = 自己最大需要的 - 已经拥有的`。即 `Need = Max - Allocation`。

## Request 向量（Work 向量）

表示进程**请求的各类资源数**，每个元素表示该进程请求的该类资源数。是当前进程请求的。

显然，请求后，系统中的资源数会减少，即 `Available -= Request`。

## 解题步骤

别去背诵那几个公式，跟着操作系统的流程来就行：

1. 有那么多进程需要排序，首先肯定是找出他们还要多少资源，也就是 `Need = Max - Allocation`。
2. 然后看看系统还有多少资源，也就是 `Available`。下一步系统需要从 `Available` 里分资源给这个进程。参考**贪心算法**，先满足那些需要资源少的进程。如果最少的都满足不了，立即推-->**不安全**。
3. 如果有进程满足了，那么就把这个进程的资源分配给它，操作系统占有的资源减少，进程持有的增加。也就是 `进程当前持有资源 += 需要的资源`。同时，这些资源是找操作系统要的，更新 `Available -= 当前进程新申请的那部分`。当然进程自己的需求不一定被完整满足，更新 `Need -= 申请来的`。
4. 这个进程执行完成后会**释放自己所有的资源**，操作系统回收了当前进程占有的一切。更新 `Available += 当前进程持有的全部资源`。
5. 删去当前进程那一行，重复 1-4 即可得到安全序列。

## 资源分配图

这个也是，王道把这么简单的东西说的完全看不懂。这部分其实是**死锁检测和解除**部分的。银行家算法是**死锁预防**。

1. 在分配图里面找一个进程，这个进程是不阻塞的。就是说，给它分配资源的那个框框没有被**超分**。
2. 删除这个进程所有的边。
3. 重复 1-2 直到所有进程都被删除。若最后无法删除，立即推-->**死锁**。

死锁解除：

1. 挂起进程，回收资源。
2. kill 进程。
3. 让进程时间倒流，退回到发生死锁之前。（设置还原点）